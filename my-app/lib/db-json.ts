import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import bcrypt from 'bcryptjs';

// Types
interface Database {
  users: any[];
  guru_bk: any[];
  layanan_bk: any[];
  guru_layanan: any[];
  periode_pemilihan: any[];
  jadwal_konseling: any[];
  history_konseling: any[];
  notifikasi: any[];
  pengaturan_user: any[];
  pengaturan_sistem: any[];
  log_aktivitas: any[];
  laporan_konseling: any[];
  backup_log: any[];
}

// File path
const dataDir = join(process.cwd(), 'data');
const filePath = join(dataDir, 'database.json');

// Default data
const defaultData: Database = {
  users: [],
  guru_bk: [],
  layanan_bk: [],
  guru_layanan: [],
  periode_pemilihan: [],
  jadwal_konseling: [],
  history_konseling: [],
  notifikasi: [],
  pengaturan_user: [],
  pengaturan_sistem: [],
  log_aktivitas: [],
  laporan_konseling: [],
  backup_log: [],
};

// Cache untuk performa
let dbCache: Database | null = null;
let cacheTimestamp = 0;
const CACHE_TTL = 1000; // 1 second cache

// Load database
function loadDB(): Database {
  const now = Date.now();
  
  // Use cache if still valid
  if (dbCache && (now - cacheTimestamp) < CACHE_TTL) {
    return dbCache;
  }

  // Ensure data directory exists
  if (!existsSync(dataDir)) {
    mkdirSync(dataDir, { recursive: true });
  }

  // Load or create database file
  if (!existsSync(filePath)) {
    dbCache = JSON.parse(JSON.stringify(defaultData));
    // Initialize synchronously with pre-generated hash
    initializeDefaultDataSync();
    saveDB();
    return dbCache;
  }

  try {
    const fileContent = readFileSync(filePath, 'utf-8');
    const parsed = JSON.parse(fileContent);
    
    // Check if database is empty or needs initialization
    if (!parsed.users || parsed.users.length === 0) {
      dbCache = JSON.parse(JSON.stringify(defaultData));
      initializeDefaultDataSync();
      saveDB();
    } else {
      dbCache = parsed;
      cacheTimestamp = now;
    }
    
    return dbCache!;
  } catch (error) {
    console.error('Error loading database:', error);
    dbCache = JSON.parse(JSON.stringify(defaultData));
    initializeDefaultDataSync();
    saveDB();
    return dbCache;
  }
}

// Save database
function saveDB(): void {
  try {
    writeFileSync(filePath, JSON.stringify(dbCache, null, 2), 'utf-8');
    cacheTimestamp = Date.now();
  } catch (error) {
    console.error('Error saving database:', error);
    throw error;
  }
}

// Initialize default data (synchronous version with pre-generated hash)
function initializeDefaultDataSync() {
  if (!dbCache) return;
  
  // Use a pre-generated bcrypt hash for "password123"
  // This hash is generated with: bcrypt.hash('password123', 10)
  // Note: Each hash generation produces different result, but all are valid
  // The actual hash in database.json will be used (generated by init script)
  const passwordHash = '$2b$10$JlIXr0ViRhSfjISyfxDcf.aFnFFtwuUL1BrJY9OWVk6uZL10tr4pG';
  
  // Default users
  if (dbCache.users.length === 0) {
    dbCache.users = [
      {
        id: 1,
        username: 'superadmin',
        email: 'superadmin@smktarunabhakti.sch.id',
        password_hash: passwordHash,
        role: 'super_admin',
        nama_lengkap: 'Super Administrator',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 2,
        username: 'admin01',
        email: 'admin@smktarunabhakti.sch.id',
        password_hash: passwordHash,
        role: 'admin',
        nama_lengkap: 'Admin BK',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 3,
        username: 'siswa001',
        nisn: '1234567890',
        email: 'siswa001@student.smktarunabhakti.sch.id',
        password_hash: passwordHash,
        role: 'siswa',
        nama_lengkap: 'Ahmad Rizki',
        jenis_kelamin: 'L',
        tanggal_lahir: '2007-05-15',
        alamat: 'Jl. Merdeka No. 123, Jakarta',
        no_telepon: '081234567896',
        kelas: 'XII',
        jurusan: 'Teknik Informatika',
        tahun_masuk: 2022,
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 4,
        username: 'siswa002',
        nisn: '1234567891',
        email: 'siswa002@student.smktarunabhakti.sch.id',
        password_hash: passwordHash,
        role: 'siswa',
        nama_lengkap: 'Siti Nurhaliza',
        jenis_kelamin: 'P',
        tanggal_lahir: '2007-08-20',
        alamat: 'Jl. Sudirman No. 456, Jakarta',
        no_telepon: '081234567897',
        kelas: 'XII',
        jurusan: 'Akuntansi',
        tahun_masuk: 2022,
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 5,
        username: 'siswa003',
        nisn: '1234567892',
        email: 'siswa003@student.smktarunabhakti.sch.id',
        password_hash: passwordHash,
        role: 'siswa',
        nama_lengkap: 'Budi Santoso',
        jenis_kelamin: 'L',
        tanggal_lahir: '2007-03-10',
        alamat: 'Jl. Gatot Subroto No. 789, Jakarta',
        no_telepon: '081234567898',
        kelas: 'XI',
        jurusan: 'Teknik Mesin',
        tahun_masuk: 2023,
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
    ];
  }

  // Default layanan BK
  if (dbCache.layanan_bk.length === 0) {
    dbCache.layanan_bk = [
      {
        id: 1,
        kode_layanan: 'AKADEMIK',
        nama_layanan: 'Konseling Akademik',
        deskripsi: 'Bimbingan untuk masalah akademik dan pembelajaran',
        icon: 'book',
        warna: '#3B82F6',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 2,
        kode_layanan: 'KARIR',
        nama_layanan: 'Bimbingan Karir',
        deskripsi: 'Bimbingan untuk perencanaan karir dan masa depan',
        icon: 'briefcase',
        warna: '#10B981',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 3,
        kode_layanan: 'PRIBADI',
        nama_layanan: 'Bimbingan Pribadi',
        deskripsi: 'Bimbingan untuk masalah pribadi dan pengembangan diri',
        icon: 'user',
        warna: '#8B5CF6',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 4,
        kode_layanan: 'SOSIAL',
        nama_layanan: 'Bimbingan Sosial',
        deskripsi: 'Bimbingan untuk masalah sosial dan hubungan',
        icon: 'users',
        warna: '#F59E0B',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 5,
        kode_layanan: 'KELUARGA',
        nama_layanan: 'Konseling Keluarga',
        deskripsi: 'Bimbingan untuk masalah keluarga',
        icon: 'home',
        warna: '#EC4899',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 6,
        kode_layanan: 'KESEHATAN',
        nama_layanan: 'Kesehatan Mental',
        deskripsi: 'Bimbingan untuk kesehatan mental dan psikologi',
        icon: 'heart',
        warna: '#EF4444',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
    ];
  }

  // Default guru BK
  if (dbCache.guru_bk.length === 0) {
    dbCache.guru_bk = [
      {
        id: 1,
        nama_lengkap: 'Ibu Siti Aminah, S.Pd',
        jenis_kelamin: 'P',
        email: 'siti.aminah@smktarunabhakti.sch.id',
        no_telepon: '081234567890',
        spesialisasi: 'Konseling Akademik & Karir',
        pendidikan_terakhir: 'S1 Pendidikan Bimbingan Konseling',
        tahun_mulai_mengajar: 2015,
        bio: 'Berpengalaman lebih dari 8 tahun dalam bimbingan konseling akademik dan karir.',
        foto_profil: 'https://ui-avatars.com/api/?name=Siti+Aminah&size=200&background=3b82f6&color=fff',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 2,
        nama_lengkap: 'Bapak Ahmad Fauzi, M.Pd',
        jenis_kelamin: 'L',
        email: 'ahmad.fauzi@smktarunabhakti.sch.id',
        no_telepon: '081234567891',
        spesialisasi: 'Bimbingan Pribadi & Sosial',
        pendidikan_terakhir: 'S2 Bimbingan Konseling',
        tahun_mulai_mengajar: 2012,
        bio: 'Spesialis dalam bimbingan pribadi dan sosial untuk remaja.',
        foto_profil: 'https://ui-avatars.com/api/?name=Ahmad+Fauzi&size=200&background=10b981&color=fff',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 3,
        nama_lengkap: 'Ibu Dewi Lestari, S.Psi',
        jenis_kelamin: 'P',
        email: 'dewi.lestari@smktarunabhakti.sch.id',
        no_telepon: '081234567892',
        spesialisasi: 'Psikologi & Kesehatan Mental',
        pendidikan_terakhir: 'S1 Psikologi',
        tahun_mulai_mengajar: 2018,
        bio: 'Ahli dalam psikologi remaja dan kesehatan mental.',
        foto_profil: 'https://ui-avatars.com/api/?name=Dewi+Lestari&size=200&background=8b5cf6&color=fff',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 4,
        nama_lengkap: 'Bapak Rizki Pratama, S.Pd',
        jenis_kelamin: 'L',
        email: 'rizki.pratama@smktarunabhakti.sch.id',
        no_telepon: '081234567893',
        spesialisasi: 'Pengembangan Diri & Motivasi',
        pendidikan_terakhir: 'S1 Pendidikan Bimbingan Konseling',
        tahun_mulai_mengajar: 2016,
        bio: 'Fokus pada pengembangan diri dan motivasi siswa.',
        foto_profil: 'https://ui-avatars.com/api/?name=Rizki+Pratama&size=200&background=f59e0b&color=fff',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 5,
        nama_lengkap: 'Ibu Fitri Handayani, M.Psi',
        jenis_kelamin: 'P',
        email: 'fitri.handayani@smktarunabhakti.sch.id',
        no_telepon: '081234567894',
        spesialisasi: 'Konseling Keluarga',
        pendidikan_terakhir: 'S2 Psikologi',
        tahun_mulai_mengajar: 2014,
        bio: 'Spesialis konseling keluarga dan masalah remaja.',
        foto_profil: 'https://ui-avatars.com/api/?name=Fitri+Handayani&size=200&background=ec4899&color=fff',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      {
        id: 6,
        nama_lengkap: 'Bapak Andi Wijaya, S.Pd',
        jenis_kelamin: 'L',
        email: 'andi.wijaya@smktarunabhakti.sch.id',
        no_telepon: '081234567895',
        spesialisasi: 'Bimbingan Karir & Prestasi',
        pendidikan_terakhir: 'S1 Pendidikan Bimbingan Konseling',
        tahun_mulai_mengajar: 2017,
        bio: 'Ahli dalam bimbingan karir dan peningkatan prestasi.',
        foto_profil: 'https://ui-avatars.com/api/?name=Andi+Wijaya&size=200&background=ef4444&color=fff',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
    ];
  }

  // Default guru_layanan
  if (dbCache.guru_layanan.length === 0) {
    dbCache.guru_layanan = [
      { id: 1, guru_id: 1, layanan_id: 1 },
      { id: 2, guru_id: 1, layanan_id: 2 },
      { id: 3, guru_id: 2, layanan_id: 3 },
      { id: 4, guru_id: 2, layanan_id: 4 },
      { id: 5, guru_id: 3, layanan_id: 3 },
      { id: 6, guru_id: 3, layanan_id: 6 },
      { id: 7, guru_id: 4, layanan_id: 3 },
      { id: 8, guru_id: 5, layanan_id: 5 },
      { id: 9, guru_id: 6, layanan_id: 2 },
      { id: 10, guru_id: 6, layanan_id: 1 },
    ];
  }

  // Default pengaturan sistem
  if (dbCache.pengaturan_sistem.length === 0) {
    dbCache.pengaturan_sistem = [
      { id: 1, kategori: 'notifikasi', key_setting: 'notifikasi_aktif', value_setting: 'true', created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      { id: 2, kategori: 'notifikasi', key_setting: 'notifikasi_email', value_setting: 'true', created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      { id: 3, kategori: 'sistem', key_setting: 'backup_otomatis', value_setting: 'true', created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      { id: 4, kategori: 'sistem', key_setting: 'maintenance_mode', value_setting: 'false', created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      { id: 5, kategori: 'konseling', key_setting: 'max_sesi_per_hari', value_setting: '10', created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      { id: 6, kategori: 'konseling', key_setting: 'durasi_sesi_menit', value_setting: '60', created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
    ];
  }
}

// Helper functions
function getNextId(collection: any[]): number {
  if (collection.length === 0) return 1;
  return Math.max(...collection.map(item => item.id || 0)) + 1;
}

// Query functions (SQL-like interface for compatibility)
export async function query<T = any>(sql: string, params?: any[]): Promise<T[]> {
  const db = loadDB();
  
  // Handle JOIN queries (guru_bk with layanan)
  if (sql.includes('guru_bk') && sql.includes('guru_layanan') && sql.includes('layanan_bk')) {
    let gurus = db.guru_bk.filter(g => !g.deleted_at);
    const guruLayanan = db.guru_layanan;
    const layanan = db.layanan_bk.filter(l => l.is_active);
    
    // Apply is_active filter if present
    if (sql.includes('gb.is_active = ?') && params && params.length > 0) {
      const isActiveParam = params.find((p, idx) => {
        // Find which param corresponds to is_active
        const beforeIsActive = sql.substring(0, sql.indexOf('gb.is_active = ?'));
        const questionMarks = (beforeIsActive.match(/\?/g) || []).length;
        return idx === questionMarks;
      });
      
      if (isActiveParam !== undefined) {
        const isActiveValue = isActiveParam === 'true' || isActiveParam === true;
        gurus = gurus.filter(g => g.is_active === isActiveValue);
      }
    }
    
    let result = gurus.map(guru => {
      const layananIds = guruLayanan
        .filter(gl => gl.guru_id === guru.id)
        .map(gl => gl.layanan_id);
      
      const layananNames = layanan
        .filter(l => layananIds.includes(l.id))
        .map(l => l.nama_layanan);
      
      return {
        ...guru,
        layanan: layananNames.join(', '),
      };
    });
    
    return result.sort((a: any, b: any) => a.nama_lengkap.localeCompare(b.nama_lengkap)) as T[];
  }
  
  // Handle JOIN queries (jadwal_konseling with relations)
  if (sql.includes('jadwal_konseling') && sql.includes('INNER JOIN')) {
    const jadwal = db.jadwal_konseling.filter(j => !j.deleted_at);
    const users = db.users;
    const gurus = db.guru_bk;
    const layanan = db.layanan_bk;
    
    let result = jadwal.map(j => {
      const siswa = users.find(u => u.id === j.siswa_id);
      const guru = gurus.find(g => g.id === j.guru_id);
      const layananItem = layanan.find(l => l.id === j.layanan_id);
      
      // Apply filters
      if (params) {
        let paramIndex = 0;
        if (sql.includes('jk.siswa_id = ?')) {
          const idx = sql.indexOf('jk.siswa_id = ?');
          const value = params[paramIndex];
          if (j.siswa_id !== parseInt(value)) return null;
          paramIndex++;
        }
        if (sql.includes('jk.guru_id = ?')) {
          const idx = sql.indexOf('jk.guru_id = ?');
          const value = params[paramIndex];
          if (j.guru_id !== parseInt(value)) return null;
          paramIndex++;
        }
        if (sql.includes('jk.status = ?')) {
          const value = params[paramIndex];
          if (j.status !== value) return null;
          paramIndex++;
        }
      }
      
      return {
        ...j,
        nama_siswa: siswa?.nama_lengkap || '',
        nisn: siswa?.nisn || '',
        nama_guru: guru?.nama_lengkap || '',
        foto_guru: guru?.foto_profil || '',
        nama_layanan: layananItem?.nama_layanan || '',
        warna: layananItem?.warna || '',
      };
    }).filter(Boolean);
    
    // Sort
    if (sql.includes('ORDER BY jk.tanggal DESC')) {
      result = result.sort((a: any, b: any) => {
        const dateA = new Date(`${a.tanggal} ${a.waktu_mulai}`).getTime();
        const dateB = new Date(`${b.tanggal} ${b.waktu_mulai}`).getTime();
        return dateB - dateA;
      });
    }
    
    return result as T[];
  }
  
  // Simple SELECT * FROM table
  const tableMatch = sql.match(/FROM\s+(\w+)/i);
  if (tableMatch) {
    const table = tableMatch[1] as keyof Database;
    let collection = (db[table] || []) as any[];
    
    // Filter deleted
    collection = collection.filter((item: any) => !item.deleted_at);
    
    // Apply WHERE conditions
    if (params && params.length > 0) {
      let paramIndex = 0;
      collection = collection.filter((item: any) => {
        // WHERE id = ?
        if (sql.includes('id = ?')) {
          return item.id === params[paramIndex++];
        }
        // WHERE user_id = ?
        if (sql.includes('user_id = ?')) {
          return item.user_id === parseInt(params[paramIndex++]);
        }
        // WHERE is_active = ?
        if (sql.includes('is_active = ?')) {
          const value = params[paramIndex++];
          return item.is_active === (value === 'true' || value === true);
        }
        // WHERE is_read = ?
        if (sql.includes('is_read = ?')) {
          const value = params[paramIndex++];
          return item.is_read === (value === 'true' || value === true);
        }
        // WHERE siswa_id = ?
        if (sql.includes('siswa_id = ?')) {
          return item.siswa_id === parseInt(params[paramIndex++]);
        }
        return true;
      });
    }
    
    // Apply ORDER BY
    if (sql.includes('ORDER BY')) {
      const orderMatch = sql.match(/ORDER BY\s+(\w+\.?\w*)\s+(ASC|DESC)?/i);
      if (orderMatch) {
        const field = orderMatch[1].split('.').pop() || orderMatch[1];
        const direction = orderMatch[2]?.toUpperCase() || 'ASC';
        collection.sort((a: any, b: any) => {
          const aVal = a[field];
          const bVal = b[field];
          if (direction === 'DESC') {
            return bVal > aVal ? 1 : -1;
          }
          return aVal > bVal ? 1 : -1;
        });
      }
    }
    
    // Apply LIMIT
    const limitMatch = sql.match(/LIMIT\s+(\d+)/i);
    if (limitMatch) {
      const limit = parseInt(limitMatch[1]);
      collection = collection.slice(0, limit);
    }
    
    return collection as T[];
  }
  
  return [];
}

export async function queryOne<T = any>(sql: string, params?: any[]): Promise<T | null> {
  const results = await query<T>(sql, params);
  return results.length > 0 ? results[0] : null;
}

export async function execute(sql: string, params?: any[]): Promise<any> {
  const db = loadDB();
  
  // Parse SQL to determine operation
  if (sql.toUpperCase().startsWith('INSERT')) {
    const tableMatch = sql.match(/INTO\s+(\w+)/i);
    if (!tableMatch) throw new Error('Invalid INSERT statement');
    
    const table = tableMatch[1] as keyof Database;
    const collection = db[table] as any[];
    
    // Extract columns and values
    const columnsMatch = sql.match(/\(([^)]+)\)/);
    if (!columnsMatch) throw new Error('Invalid INSERT columns');
    
    const columns = columnsMatch[1].split(',').map(c => c.trim());
    const newItem: any = {
      id: getNextId(collection),
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    
    // Map params to columns
    if (params) {
      columns.forEach((col, idx) => {
        if (params[idx] !== undefined && params[idx] !== null) {
          newItem[col] = params[idx];
        }
      });
    }
    
    collection.push(newItem);
    saveDB();
    return { insertId: newItem.id, affectedRows: 1 };
  }
  
  if (sql.toUpperCase().startsWith('UPDATE')) {
    const tableMatch = sql.match(/UPDATE\s+(\w+)/i);
    if (!tableMatch) throw new Error('Invalid UPDATE statement');
    
    const table = tableMatch[1] as keyof Database;
    const collection = db[table] as any[];
    
    // Parse SET clause
    const setMatch = sql.match(/SET\s+(.+?)(?:\s+WHERE|$)/i);
    const whereMatch = sql.match(/WHERE\s+(.+?)(?:\s+ORDER|$)/i);
    
    if (!setMatch) throw new Error('Invalid UPDATE SET clause');
    
    // Parse SET fields
    const setFields: any = {};
    const setClause = setMatch[1];
    const setParts = setClause.split(',').map(s => s.trim());
    
    let paramIndex = 0;
    setParts.forEach(part => {
      const [key, value] = part.split('=').map(s => s.trim());
      if (value === 'NOW()') {
        setFields[key] = new Date().toISOString();
      } else if (value === '?') {
        if (params && params[paramIndex] !== undefined) {
          setFields[key] = params[paramIndex];
          paramIndex++;
        }
      } else {
        setFields[key] = value.replace(/['"]/g, '');
      }
    });
    
    let updated = 0;
    collection.forEach((item: any) => {
      if (item.deleted_at) return;
      
      // Check WHERE condition
      let matches = true;
      if (whereMatch && params) {
        const condition = whereMatch[1];
        if (condition.includes('id = ?')) {
          matches = item.id === parseInt(params[paramIndex]);
          paramIndex++;
        } else if (condition.includes('user_id = ?')) {
          matches = item.user_id === parseInt(params[paramIndex]);
          paramIndex++;
        } else if (condition.includes('key_setting = ?')) {
          matches = item.key_setting === params[paramIndex];
          paramIndex++;
        }
      }
      
      if (matches) {
        Object.assign(item, setFields);
        item.updated_at = new Date().toISOString();
        updated++;
      }
    });
    
    saveDB();
    return { affectedRows: updated };
  }
  
  return { affectedRows: 0 };
}

// User-specific functions
export async function getUserByIdentifier(identifier: string, role?: string): Promise<any | null> {
  const db = loadDB();
  const users = db.users.filter(u => u.is_active && !u.deleted_at);
  
  let user = users.find(u => 
    u.username === identifier || 
    u.email === identifier || 
    u.nisn === identifier
  );

  if (user && role) {
    if (user.role !== role) {
      return null;
    }
  }

  return user || null;
}

export async function updateLastLogin(userId: number): Promise<void> {
  const db = loadDB();
  const user = db.users.find(u => u.id === userId);
  if (user) {
    user.last_login = new Date().toISOString();
    user.updated_at = new Date().toISOString();
    saveDB();
  }
}

export async function getAllSiswa(kelas?: string, jurusan?: string): Promise<any[]> {
  const db = loadDB();
  let siswa = db.users.filter(u => 
    u.role === 'siswa' && 
    u.is_active && 
    !u.deleted_at
  );

  if (kelas) {
    siswa = siswa.filter(s => s.kelas === kelas);
  }

  if (jurusan) {
    siswa = siswa.filter(s => s.jurusan === jurusan);
  }

  return siswa.sort((a, b) => a.nama_lengkap.localeCompare(b.nama_lengkap));
}

export async function searchUsers(searchTerm: string, role?: string): Promise<any[]> {
  const db = loadDB();
  let users = db.users.filter(u => 
    u.is_active && 
    !u.deleted_at &&
    (
      u.username?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      u.email?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      u.nisn?.includes(searchTerm) ||
      u.nama_lengkap?.toLowerCase().includes(searchTerm.toLowerCase())
    )
  );

  if (role) {
    users = users.filter(u => u.role === role);
  }

  return users.slice(0, 50).sort((a, b) => a.nama_lengkap.localeCompare(b.nama_lengkap));
}

// Initialize on first load
// This will create database.json if it doesn't exist
loadDB();
